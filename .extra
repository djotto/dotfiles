#!/usr/bin/env bash

# This file runs last, and contains overrides

# This block overrides code in .aliases
# Replace MacOS's ls with GNU's ls. GNU's ls is available in brew's coreutils.

# Check if gls exists and set the appropriate color flags and environmental variables
if type gls &>/dev/null; then
	colorflag="--color"

	LS_COLORS="rs=$(get_color_ls):"                          # reset
	LS_COLORS+="no=$(get_color_ls):"                         # normal text
	LS_COLORS+="fi=$(get_color_ls):"                         # regular files
	LS_COLORS+="di=$(get_color_ls 'blue' '' 'bold'):"        # directories
	LS_COLORS+="ln=$(get_color_ls 'cyan' '' 'bold'):"        # symbolic links
	LS_COLORS+="pi=$(get_color_ls 'yellow' 'black'):"        # pipes
	LS_COLORS+="so=$(get_color_ls 'magenta' '' 'bold'):"     # sockets
	LS_COLORS+="do=$(get_color_ls 'magenta' '' 'bold'):"     # doors
	LS_COLORS+="bd=$(get_color_ls 'yellow' 'black' 'bold'):" # block devices
	LS_COLORS+="cd=$(get_color_ls 'yellow' 'black' 'bold'):" # character devices
	LS_COLORS+="or=$(get_color_ls 'red' 'black' 'bold'):"    # orphan symbolic links
	LS_COLORS+="ex=$(get_color_ls 'green' '' 'bold'):"       # executables
	# archive files
	LS_COLORS+="*.tar=$(get_color_ls 'red' '' 'bold'):*.tgz=$(get_color_ls 'red' '' 'bold'):*.arj=$(get_color_ls 'red' '' 'bold'):*.taz=$(get_color_ls 'red' '' 'bold'):*.lzh=$(get_color_ls 'red' '' 'bold'):*.zip=$(get_color_ls 'red' '' 'bold'):*.z=$(get_color_ls 'red' '' 'bold'):*.Z=$(get_color_ls 'red' '' 'bold'):*.gz=$(get_color_ls 'red' '' 'bold'):*.bz2=$(get_color_ls 'red' '' 'bold'):*.deb=$(get_color_ls 'red' '' 'bold'):*.rpm=$(get_color_ls 'red' '' 'bold'):*.jar=$(get_color_ls 'red' '' 'bold'):"
	# multimedia files
	LS_COLORS+="*.jpg=$(get_color_ls 'magenta' '' 'bold'):*.jpeg=$(get_color_ls 'magenta' '' 'bold'):*.gif=$(get_color_ls 'magenta' '' 'bold'):*.bmp=$(get_color_ls 'magenta' '' 'bold'):*.pbm=$(get_color_ls 'magenta' '' 'bold'):*.pgm=$(get_color_ls 'magenta' '' 'bold'):*.ppm=$(get_color_ls 'magenta' '' 'bold'):*.tga=$(get_color_ls 'magenta' '' 'bold'):*.xbm=$(get_color_ls 'magenta' '' 'bold'):*.xpm=$(get_color_ls 'magenta' '' 'bold'):*.tif=$(get_color_ls 'magenta' '' 'bold'):*.tiff=$(get_color_ls 'magenta' '' 'bold'):*.png=$(get_color_ls 'magenta' '' 'bold'):*.mov=$(get_color_ls 'magenta' '' 'bold'):*.mpg=$(get_color_ls 'magenta' '' 'bold'):*.mpeg=$(get_color_ls 'magenta' '' 'bold'):*.avi=$(get_color_ls 'magenta' '' 'bold'):*.fli=$(get_color_ls 'magenta' '' 'bold'):*.gl=$(get_color_ls 'magenta' '' 'bold'):*.dl=$(get_color_ls 'magenta' '' 'bold'):*.xcf=$(get_color_ls 'magenta' '' 'bold'):*.xwd=$(get_color_ls 'magenta' '' 'bold'):*.ogg=$(get_color_ls 'magenta' '' 'bold'):*.mp3=$(get_color_ls 'magenta' '' 'bold'):*.wav=$(get_color_ls 'magenta' '' 'bold'):"
	export LS_COLORS
	ls_cmd="gls"
else
	# this is untested.
	colorflag="-G"
	export LSCOLORS='BxBxhxDxfxhxhxhxhxcxcx'
	ls_cmd="ls"
fi

# Define aliases using the determined command and color flag
alias l="command ${ls_cmd} -lF ${colorflag}"
alias la="command ${ls_cmd} -lAF ${colorflag}"
alias lsd="command ${ls_cmd} -lF ${colorflag} | grep --color=never '^d'"
alias ls="command ${ls_cmd} ${colorflag}"

# This block overrides code in .bash_prompt
# Based on https://gist.github.com/gf3/306785/a35d28b6bdd0f7c54318cce510738438f04dabaa

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
	export TERM='gnome-256color';
elif infocmp xterm-256color >/dev/null 2>&1; then
	export TERM='xterm-256color';
fi;

if [[ $COLORTERM = gnome-* && $TERM = xterm ]]  && infocmp gnome-256color >/dev/null 2>&1; then TERM=gnome-256color; fi
if tput setaf 1 &> /dev/null; then
	tput sgr0
	# I don't bother using the 256-colour palette, because I tweak these colors to exactly what I want in iTerm2
	# Standard colors
	BLACK=$(tput setaf 0)
	RED=$(tput setaf 1)
	GREEN=$(tput setaf 2)
	YELLOW=$(tput setaf 3)
	BLUE=$(tput setaf 4)
	MAGENTA=$(tput setaf 5)
	CYAN=$(tput setaf 6)
	WHITE=$(tput setaf 7)
	# Bright colors
	BLACK_BRIGHT=$(tput setaf 8)
	RED_BRIGHT=$(tput setaf 9)
	GREEN_BRIGHT=$(tput setaf 10)
	YELLOW_BRIGHT=$(tput setaf 11)
	BLUE_BRIGHT=$(tput setaf 12)
	MAGENTA_BRIGHT=$(tput setaf 13)
	CYAN_BRIGHT=$(tput setaf 14)
	WHITE_BRIGHT=$(tput setaf 15)
	BOLD=$(tput bold)
	RESET=$(tput sgr0)
else
	# Standard colors
	BLACK='\033[30m'
	RED='\033[31m'
	GREEN='\033[32m'
	YELLOW='\033[33m'
	BLUE='\033[34m'
	MAGENTA='\033[35m'
	CYAN='\033[36m'
	WHITE='\033[37m'
	# Bright colors
	BLACK_BRIGHT='\033[90m'
	RED_BRIGHT='\033[91m'
	GREEN_BRIGHT='\033[92m'
	YELLOW_BRIGHT='\033[93m'
	BLUE_BRIGHT='\033[94m'
	MAGENTA_BRIGHT='\033[95m'
	CYAN_BRIGHT='\033[96m'
	WHITE_BRIGHT='\033[97m'

	BOLD=""
	RESET="\033[m"
fi

unset prompt_git

function parse_git_dirty() {
    if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        # Check if the working directory is dirty
        if [[ $(git status --porcelain) ]]; then
            echo "*"
        fi
    fi
}

function parse_git_branch() {
	git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1/"
}

# Highlight the hostname when connected via SSH.
if [[ "${SSH_TTY}" ]]; then
	HOSTSTYLE="${BOLD}${RED}";
else
	HOSTSTYLE="${CYAN}";
fi;

PS1="\[${CYAN}\]\u\[$RESET\]@\[$HOSTSTYLE\]\h\[$RESET\]:\[$BLUE\]\w\[$RESET\]\$([[ -n \$(git branch 2> /dev/null) ]] && echo \" on \")\[$MAGENTA\]\$(parse_git_branch)\[$MAGENTA_BRIGHT\]\$(parse_git_dirty)\[$RESET\]\n\$ \[$RESET\]"
